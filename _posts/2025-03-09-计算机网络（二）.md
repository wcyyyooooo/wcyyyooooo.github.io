---
layout: post
title:  "计算机网络（二）"
categories: 408
---

## 第四章 网络层
在最开始电信网络的时候常常使用可靠的虚电路服务，在互联网设计过程中，网络层只提供不可靠服务。可靠性要靠上一层来保证。
| 虚电路服务| 数据报服务 |
|-------|-------|
|必须建立连接|无需建立连接|
|地址仅在建立连接时需要，连接建立之后仅使用虚电路号|每个分组都有完整地址|
|同一条虚电路分组均按照同一条路由转发|每个分组独立选择路由|
|节点出现故障会导致整条虚电路失效|节点故障不一定会|
|总是按顺序到达|不一定按顺序到达|
|可靠传输由网络层负责|由更高层负责（运输层的TCP协议）|

### IP地址表示方法
* 分类的IP地址：
![alt text](/asset/images/image12.png)
![alt text](/asset/images/image13.png)
对于A类地址全为0表示本网络，全为1（网络号为127）用于本主机环回测试，不进行分配。主机号全为0表示本网络，全为1表示所有主机用于广播。
![alt text](/asset/images/image14.png)
* 划分子网：可将IP地址写成IP地址：={<网络号>，<子网号>，<主机号>}
    * 子网掩码：把IP地址与子网掩码相与可得到网络地址。
* CIDR：把IP地址写成IP地址:={<网络前缀>，<主机号>}
    * 路由聚合（构造超网）：对于多个路由取公共前缀，作为网络前缀，可以减少路由表项的数量。
    * 最长前缀匹配：对于路由选择时，选择那个最长前缀匹配的表项来转发。

### ARP协议
每一台主机都有ARP高速缓存，维护了从IP地址到硬件地址的映射。
主机A要向同一个局域网的主机B发送IP数据报：
* 如果A的高速缓存中含有B的mac地址，就把这个mac地址填入mac帧中。
* 如果A告诉缓存中没有B的mac地址：
    * 向本局域网内发送广播帧（ARP请求报文），源mac地址和源IP地址为A的mac地址和IP地址，目的IP地址为B的IP地址，目的mac地址是全1（意思为广播帧）。
    * B收到广播帧，向A发送ARP响应报文（单播）

ARP协议是解决同一个局域网中的IP地址到MAC地址映射的问题的。
![alt text](/asset/images/image15.png)
对于不同局域网的映射问题，使用多次ARP协议来解决。

### IPv4数据报格式
![alt text](/asset/images/image16.png)
* 版本：4位指IP协议的版本，4表示IPv4，6表示IPv6。
* 首部长度：占4位，单位为4个字节，最大为15表示首部为60字节，最小为5表示20字节，没有任何扩充。
* 总长度：占16位，是首部和数据部分的总长度。最大可表示$2^{16} - 1$字节。
* 标识：占16位，由于MAC帧的数据部分只有1500字节，对于某些IP数据包需要分片。标识字段相同的IP数据报属于同一个IP数据报。
* 标志：占3位
    * 最低为MF（More Fragment）,MF = 1表示后面还有分片，MF = 0表示后面没有分片了。
    * 中间一位为DF（don't Fragment）,DF = 0表示不能分片。
* 片偏移：占13位，以8字节为单位，如果片偏移为97，证明前面有97 * 8字节。
* TTL生存时间：占8位，可以经过最多255个路由器，每次被路由器转发出去TTL就会减1，如果被减为0就把这个数据报丢弃。如果发出一个TTL=1的数据报，这个数据报只能在本网络中传送。
* 协议：占8位，协议字段指出数据报携带的数据是什么协议
![alt text](/asset/images/image17.png)
* 首部校验和：二进制反码计算，以后补充

### IPv6
IPv6引进了如下变化：
* 更大的地址空间，32位->128位（16字节）。
* 扩展的地址层次结构
* 灵活的首部格式：IPv6首部长度固定，扩展首部都放在有效载荷中。
* 允许协议继续扩充
* 支持即插即用：不使用DHCP
* 支持资源预分配
* 首部8字节对齐

IPv6和IPv4对比：
* 取消了首部长度字段
* 取消服务类型字段
* 取消了总长度字段：改用有效载荷长度字段。
* 取消标识和片偏移字段：功能包含在扩展首部中。
* 取消协议字段：改用下一个首部字段。
* 取消校验和字段
* 取消选项字段

![alt text](/asset/images/image24.png)
* 版本号：占4位指出协议的版本，对于IPv6来说应该是6。
* 通信量类：8位，区分不同的IPv6数据报的类别和优先级。
* 流标号：20位，IPv6提出流的抽象概念。流是指互联网上从特定源点到特定终点（单播或多播）的一系列数据报（如实时音/视频传输），而在这个“流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有相同的流标号。
* 有效载荷长度：占16位，最大64KB。
* 下一个首部：如果没有扩展首部，相当于协议字段，例如6/17分别表示TCP/UDP。如果有扩展首部标识第一个扩展首部的类型。
* 跳数限制：占8位，最多255跳。

IPv6地址有：
* 单播。就是传统的点对点通信。
* 多播。一点对多点的通信，数据报发送到一组计算机中的每一台。
* 任播。这是IPv6增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一台计算机，通常是距离最近的一台计算机。

IPv6使用冒号16进制表示法，允许把数字前面的0省略，可以把0000变成0，一连串0可以用一对冒号取代（只能用一次）。
![alt text](/asset/images/image25.png)

ipv4向ipv6过渡：
* 双协议栈：主机同时使用两个协议栈，既能使用IPv4通信也能使用IPv6通信。但是这种方式会产生损失。
![alt text](/asset/images/image26.png)
* 隧道技术：如果IPv6数据报要进入IPv4网络，就把IPv6封装到IPv4数据报中，把协议字段设置为41，就能让主机知道IPv4数据报中封装的是IPv6报文。

### ICMP
ICMP允许主机或者路由器报告差错情况和提供有关异常的情况的报告。
![alt text](/asset/images/image18.png)
ICMP报告报文被封装在IP数据报之中。
|参数|ICMP报告报文类型|含义|
|-------|-------|-------|
|3|终点不可达|路由器/主机不能交付报文向源点发送终点不可达报文|
|11|时间超过|当路由器收到生存时间为0的报文或者终点不能在规定时间内收到所有报文（丢弃所有已经收到的报文），就向源点发送时间超过报文|
|12|参数问题|当路由器或主机收到收到的数据报首部参数不正确时，丢弃数据报，并向源点发送参数问题报文|
|5|改变路由|路由器把改变路由报文发给主机让主机知道有更好的路由|

ICMP差错报告报文的数据部分是IP数据报的首部和运输层中的源端口号和目的端口号。
![alt text](/asset/images/image19.png)
![alt text](/asset/images/image20.png)
ICMP应用：
* ping:使用ICMP回送请求和回答报文
* traceroute: 使用ICMP时间超过报文和ICMP终点不可达报文。

### 路由选择协议
#### RIP
RIP是一种分布式的基于距离向量的路由选择协议。其中距离的定义为，路由器到直连网络的距离为1，从主机到非直连网络距离为经过的路由器数加1。RIP允许一条路径有最多15个网络（路径上有14个路由器），距离等于16即为不可达。RIP适用于小型互联网。
RIP不能在两个网络之间使用多条路由，只能选择距离（跳数）最少的路径。

RIP协议的特点：
* 仅和相邻路由器交换信息
* 交换的信息为整个路由表，交换的信息为到本自治系统的所有网络的最短距离和下一跳的路由器。
* 按固定时间间隔交换
* RIP收敛（得到正确的路由选择信息）速度很快

RIP算法步骤：
* 收到X路由器发过来的RIP报文，修改这个报文的所有项目，把下一跳地址均改成X，距离字段加1。每条项目都有三项，目的网络net，距离d，下一跳X。
* 如果路由表没有net这一个表项，就把该表项添加至路由表。
* 如果有net这一表项
    * 如果当前下一跳为X，则把当前表项距离更新为d。
    * 如果d小于当前距离则更新距离和下一跳路由器。
* 如果30秒没有收到相邻路由器的更新路由表则把此路由器记为不可达路由器，距离设置为16。

RIP报文使用UDP进行传送，使用UDP端口520。

RIP报文由首部和路由部分构成，路由部分填入自治系统号（ASN）,每个路由项包括目的网络地址，子网掩码，下一跳地址和距离。一个RIP报文最多包括25个路由。

好消息传得快，坏消息传得慢。

#### OSPF
OSPF主要特征就是使用链路状态协议，而不是RIP那样的距离向量协议。

OSPF协议的特点：
* 向本自治系统中所有的路由器发送信息，使用的是洪泛法（向相邻路由器发送，相邻路由器再发给相邻的）。
* 发送的信息是与本路由器相邻的所有路由器的链路状态。
* 当链路状态变化或者每隔一段时间都用洪泛法发送链路状态信息。
* OSPF允许管理员给每条路由设置不同的代价。
* 如果有多条相同的代价，就把通信量分配给这几条路径，多路径间负载均衡。
*  所有OSPF路由器之间交换的分组都有鉴别功能。
* OSPF支持的可变长度的子网划分和CIDR。
* OSPF每个链路状态都带一个32位序号，序号越大越新。

通过各个路由器之间频繁交换链路状态信息，所有路由器都能建立一个链路状态数据库（全网的拓扑结构图）。交换的信息相当与图论中的点和边权，可以通过dijkstra算法计算出两点之间的最大/最小距离和路径。

OSPF使用层次结构的区域划分，把洪泛法交换信息的范围局限于一个区域而不是整个自治系统。
![alt text](/asset/images/image21.png)

OSPF共有五种分组类型：
* 问候分组：用来发现和维护邻站的可达性。
* 数据库描述分组：向邻站给出自己数据库中所有链路状态项目的摘要信息。
* 链路状态请求分组：向对方请求某些链路状态项目的详细信息。
* 链路状态更新分组：用洪泛法对全网更新链路状态。
* 链路状态确认分组：对链路状态更新分组进行确认。

OSPF使用IP数据报来传送，协议字段号为89。OSPF构成的数据报很短，不需要分片，分片如果一个错误就必须整个重传。

规定每隔10秒，相邻的两个路由器交换一次问候分组。这样就能知道那些邻站是可达的。如果40秒没收到邻站的问候分组表示不可达。

如果所有路由器都向全网广播本地链路状态信息，这样开销太大。所以OSPF让每一个路由器用数据库描述分组交换本数据库中已有的链路状态摘要信息。根据摘要信息通过链路状态请求分组，向对方请求发送自己缺少的某些链路状态项目的信息。

如果某个路由器链路状态发生变化，该路由器使用链路状态更新分组，使用洪泛法向全网更新链路状态。OSPF使用可靠的洪泛法，收到更新分组要发送确认（只发送一次）。
![alt text](/asset/images/image22.png)

#### BGP
BGP作用是给众多的AS连接起来，BGP力求选择出一条能到达目的网络前缀且比较好的路由。BGP采用的是路径向量路由选择协议。

**BGP路由**
一个AS中有两种不同功能的路由器即边界路由器和内部路由器。
![alt text](/asset/images/image.png)
两个边界路由器进行通信必须先建立TCP连接（端口号179），这个连接称为eBGP连接。3a可以向2c发送BGP路由x，AS3,3a。这样2c就知道了到达AS3的X的BGP路由。

在AS内部，两个路由器还需要建立iBGP连接。2c通过iBGP把BGP路由通知给AS2的其他路由器。iBGP必须是全连通的

从eBGP对等端收到BGP路由，可通过iBGP转发给同一AS内的对等端。从iBGP对等端收到的BGP路由可以通过eBGP告诉其他AS对等端。但是不能把从iBGP收到的路由转发给iBGP的对等端。

BGP路由 = "前缀，BGP属性" = "前缀，AS-PATH，NEXT-HOP"
AS-PATH是通告的BGP路由所经过的自治系统，每经过一个AS就把ASN加入AS-PATH。
![alt text](/asset/images/image23.jpg)
R4如何构造转发表呢？
* R4收到了R2发过来的BGP路由x->R1
* 由于R4无法识别R1，把BGP路由改写为x->R1->R2
* 通过内部路由算法得到到R2最好的路由，下一跳为R3。
* 将R4转发表设置为R3，完整路由为x->R1->R2->R3->R4。

**BGP路由选择**
* 先选择本地偏好值高的，在BGP路由属性中有个本地偏好，由管理员设置。
* 本地偏好值相同选择具有AS跳数最少的。
* 上述均相同，使用热土豆算法，选择一条路径让分组经过最少的转发次数离开本AS（此时使用内部网关协议OSPF或者RIP）。
* 选择BGP标识符最小的一个

**BGP报文类型**
BGP刚开始运行时，BGP连接的对等端要互相交换整个路由表，以后只有有变化的时候更新有变化的部分。
* OPEN（打开）报文：用来与BGP连接对等端建立关系。
* UPDATE（更新）报文：用来通告某一路由的信息以及列出要撤销的路由。
* KEEPALIVE（保活）报文：周期性证实与对等端的连接。
* NOTIFICATION（通知）报文：用来发送检测到的差错。

TCP建立连接之后发送OPEN报文，目的是识别对方协商参数。收到OPEN报文之后就发回KEEPALIVE报文表示接受连接。

### IP多播
![alt text](/asset/images/image27.png)
单播对于每个主机都要发送一个数据报，但是组播只需要发送一个，组播路由器转发的时候会进行复制。局域网具有硬件多播的功能，不需要复制分组，每个主机都能收到分组。
**硬件多播**
![alt text](/asset/images/image28.png)
多播地址为01-00-5E-00-00-00到01-00-5E-7F-FF-FF。前25位固定（01-00-5E-0，后23位使用D类IP地址后23位。可能会重复（不同IP地址会映射成相同的多播地址）需要根据IP地址过滤以下。
**IP多播特点**
* 在互联网上的多播叫IP多播，IP多播需要使用多播IP地址。多播组的表示符为D类地址：224.0.0.0-239.255.255.255。
* 首部协议字段为2，表示使用IGMP。
* 多播地址只能用于目的地址，不能用于源地址。

**IGMP**
IGMP协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参加或退出某个多播组。IGMP使用IP数据报传递其报文，ICMP报文加上IP首部。
IGMP流程：
* 当某一台主机想要加入新的多播组应向多播组的多播地址发送一个IGMP报文，声明要成为该组的成员。本地的多播路由器收到IGMP报文后，要利用多播路由选择协议发给其他多播路由器。
* 组成员是动态的，本地路由器要周期性探测本地局域网的主机来知道是否离开了这个组。

多播路由选择实际上就是要找出以源主机为根结点的多播转发树，其中每个分组在每条链路上只传送一次（即在多播转发树上的路由器不会收到重复的多播数据报）。不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树。

### NAT
私有地址，只能用来作为本地地址不能作为全球地址。
* 10.0.0.0/8，从10.0.0.0-10.255.255.255。
* 172.16.0.0/12，从172.16.0.0-172.31.255.255。
* 192.168.0.0/16，从192.168.0.0-192.168.255.255。

![alt text](/asset/images/image28.jpg)
当NAT路由器有n个全球IP地址的时候，专用网最多可以同时有n台主机。

通过NAT路由器的通信必须由专用网内的主机发起。

现在可以将端口号加上，使多个本地地址的主机使用同一个全球IP地址（端口号不同）。

通过NAT路由器转发的IP数据报时必须改变源IP地址/目的IP地址。通过NAPT路由器还可能需要修改端口号。

## 运输层
### 协议端口号总结
| 应用层协议| 运输层协议 |端口号|
|-------|-------|----|
|DNS|UDP|53|
|RIP|UDP|520|
|DHCP|UDP||
|SMTP|TCP|25|
|FTP|TCP|20/21|
|HTTP|TCP|80|
### UDP
![alt text](/asset/images/image29.png)
* 源端口号：如果无需回信，可以全置为0。
* 目的端口号：与源端口号均为16位。
* 长度：最小为8B（仅有首部），最多64KB。
* 校验和：计算

### TCP
TCP协议特点：
* 面向连接的运输层协议
* 每一条连接都是点到点的，每个点是一个套接字（IP地址，端口号）。
* 可靠交付，无差错，不重复，不丢失且按序到达。
* 全双工通信
* 面向字节流

#### TCP报文段格式
![alt text](/asset/images/image30.png)
* 序号：4字节，长度范围为$0-2^{32} - 1$，TCP连接传送的每一个字节都按顺序编号。如果上一个报文最后一个字节序号为400，当前报文序号为401。
* 确认号：希望对方下一个报文的第一个数据字节序号。若确认号为N，表示前N - 1个字节都已经收到了。
* 数据偏移：占四位，以四个字节为单位，最大值为15，表示TCP首部最长为60字节，最小值为5，表示最短为20字节。
* URG：当URG = 1表示为紧急数据需要尽快传送，无需排队。
* ACK：ACK = 1时确认号才有效，建立连接之后ACK = 1。
* PSH：当PSH = 1的报文，立刻把TCP缓存中的数据推送上去。
* RST：RST = 1表示出现严重差错，需要进行复位（关闭连接并重新连接）。还可以用来拒绝非法的连接或拒绝打开一个连接。
* SYN：连接时建立同步序号。
* FIN： 用于释放一个连接。
* 窗口：占2字节，表示发送报文的这一方最多能接收的数据量。
* 紧急指针：URG = 1才有意义，指出紧急数据的位置。

#### TCP可靠传输
* 发送缓存和接收缓存使用以字节为单位的滑动窗口。
* 超时重传，就是TCP发送方要在规定的时间内没有收到确认，就要重传已发送的报文段。
    * 超时重传时间计算：
* 选择确认SACK：TCP接收方在接收发过来的数据时，数据字节流可能不连续。可以通过选择确认报文，报告缺少的左右边界，不必重传整个报文。

#### TCP流量控制
* 使用滑动窗口进行流量控制：
    * 使发送方不要发的太快，要让接收方来得及接受。
    * 发送方的发送窗口肯定不能超过接收方的接受窗口。TCP窗口单位是字节，不是报文段。
    * TCP中有持续计时器（为了防止B向A发送零窗口报文段之后，缓存又有了空闲，但是rwnd = 400报文段丢失，A一直等待B的非零窗口通知，B等待A发送数据，进而产生死锁）。持续计时器时间到了就发送一个零窗口的探测报文段（仅携带一字节数据）。

**TCP的传输效率**
* TCP报文的发送时机：
    * 维护一个变量当他等于最大报文段长度时，就把缓存中数据发送出去。
    * 进程要求把缓存中数据发送出去，即为PUSH操作。
    * 发送方的计时期限到了
    * Nagle算法：先发送一个字节，剩下的缓存在发送缓存之中，收到确认之后再把缓存中的数据发送出去。只有收到前一个报文段的确认之后在发送下一个。
* 傻窗口：例如TCP接受缓存已经满了，应用程序每次只取出一个字节，并向发送方发出确认，窗口设置为一个字节，发送方发送一个字节，会造成效率很低。
    * 解决办法：接收方等待一段时间或者等到接收缓存已经有了一半的空闲的空间。

### TCP拥塞控制
发送方维护一个拥塞窗口的变量cwnd，发送方的发送窗口
TCP拥塞控制方法：
* 慢开始：
![alt text](/asset/3月/image0.png)
每次收到一个确认，拥塞窗口就增加1。而不是每个RTT之后翻倍。
    * 设置一个慢开始门限值（ssthresh），当达到慢开始门限值之后转而执行拥塞避免算法。
* 拥塞避免算法，使用加法增大的方式，每个RTT窗口增加1。
![alt text](/asset/3月/image1.png)
当发生超时之后，把慢开始门限值设置为cwnd / 2，并把拥塞窗口置为1，重新执行慢开始算法。
* 快重传，当收到三个冗余ACK（四个确认报文），就立即重传不需要等待超时。
* 快恢复：将慢开始门限值设置为cwnd / 2， 之后将cwnd = ssthresh。

**超时触发慢开始，3-ACK触发快恢复**
![alt text](/asset/3月/image2.png)

#### TCP连接建立和释放
![alt text](/asset/3月/image3.png)
![alt text](/asset/3月/image4.png)

**SYN和FIN都一定消耗一个序号，但是纯的ACK（只确认）不消耗序号。**
**TCP有限自动机**
![alt text](/asset/3月/image5.png)

## 第六章 应用层
### DNS
域名相当与IP地址的一个别名，因为IP地址无法划分层次。但是域名可以划分为形如xxx.yyy.zzz。报文使用UDP传送，端口号为53。
#### 域名结构
![alt text](/asset/3月/image6.png)
#### 域名服务器
* 根域名服务器：最高层次的域名服务器，采用任播的方式，当DNS客户向某个根域名服务器发送查询报文，就发给最近的根域名服务器。
* 顶级域名服务器：例如.com
* 权限域名服务器：比如abc.com和y.abc.com各有一个域名服务器
* 本地域名服务器

#### DNS解析过程
* 递归查询：如果没有查到的话，代替本地域名服务器去作为DNS的客户，最后返回给本地域名服务器。
* 迭代查询：本地域名服务器去查询根服务器，根服务器不会代替本地域名服务器去查询，只会告诉它下一个该查那个。
![alt text](/asset/3月/image7.png)
查询y.abc.com 最多需要发送4条查询，最少0条（主机缓存中有）。

### FTP
